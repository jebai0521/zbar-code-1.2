//------------------------------------------------------------------------
//  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
//
//  This file is part of the ZBar Bar Code Reader.
//
//  The ZBar Bar Code Reader is free software; you can redistribute it
//  and/or modify it under the terms of the GNU Lesser Public License as
//  published by the Free Software Foundation; either version 2.1 of
//  the License, or (at your option) any later version.
//
//  The ZBar Bar Code Reader is distributed in the hope that it will be
//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser Public License for more details.
//
//  You should have received a copy of the GNU Lesser Public License
//  along with the ZBar Bar Code Reader; if not, write to the Free
//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
//  Boston, MA  02110-1301  USA
//
//  http://sourceforge.net/projects/zbar
//------------------------------------------------------------------------

#import <ZBarSDK/ZBarReaderView.h>

#define MODULE ZBarReaderView
#import "debug.h"

const unsigned char lineImagebytes[] = {
    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
    0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x01, 0xc8, 0x08, 0x06, 0x00, 0x00, 0x00, 0xac, 0xde, 0xd1,
    0x94, 0x00, 0x00, 0x00, 0x19, 0x74, 0x45, 0x58, 0x74, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72,
    0x65, 0x00, 0x41, 0x64, 0x6f, 0x62, 0x65, 0x20, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x61,
    0x64, 0x79, 0x71, 0xc9, 0x65, 0x3c, 0x00, 0x00, 0x08, 0xbc, 0x49, 0x44, 0x41, 0x54, 0x78, 0xda,
    0xe4, 0x5c, 0x5d, 0x92, 0x23, 0x35, 0x0c, 0x96, 0x3c, 0xd9, 0x0b, 0x40, 0x41, 0x51, 0x3c, 0xf0,
    0xc2, 0x13, 0xa7, 0xe0, 0xe2, 0xdc, 0x84, 0xe2, 0x11, 0x28, 0x8a, 0x2b, 0x10, 0x8b, 0xe9, 0x99,
    0xce, 0x8c, 0xe3, 0x96, 0xac, 0x1f, 0xcb, 0x9d, 0x99, 0xda, 0x29, 0xb2, 0xc9, 0x66, 0xd2, 0x8a,
    0xda, 0xfe, 0xf4, 0x49, 0xfa, 0x64, 0x16, 0x7f, 0xa3, 0x5f, 0x61, 0xfb, 0xf9, 0x0b, 0xfe, 0x80,
    0xfd, 0x07, 0xc1, 0xfe, 0x43, 0xdb, 0x1f, 0x3f, 0xc2, 0xcf, 0x2f, 0x7f, 0x29, 0xf8, 0x7c, 0x2d,
    0x63, 0x08, 0x9b, 0x47, 0x69, 0x1e, 0xed, 0xfb, 0x6f, 0x9f, 0xdf, 0xae, 0xdf, 0xec, 0x5c, 0x1a,
    0x47, 0x7a, 0x43, 0xfd, 0x7b, 0xd4, 0x3c, 0xb7, 0x9e, 0xed, 0xef, 0x3d, 0x1b, 0xfb, 0x13, 0x7e,
    0x97, 0x3c, 0xba, 0x79, 0x05, 0x9d, 0x91, 0xca, 0x19, 0x7c, 0xb6, 0x43, 0x97, 0xe6, 0xcd, 0xd6,
    0x00, 0x76, 0xb7, 0xd6, 0x7b, 0x72, 0x33, 0x58, 0xdb, 0xb5, 0x93, 0x8c, 0xf5, 0x0f, 0x68, 0xbc,
    0xc2, 0xce, 0xe0, 0xc1, 0xd8, 0xed, 0xdb, 0x6f, 0x17, 0x3f, 0x35, 0x8f, 0xd2, 0xdc, 0xe6, 0x66,
    0xe0, 0xba, 0x3f, 0x6e, 0x46, 0xae, 0xb7, 0xdf, 0x5f, 0x98, 0xf5, 0xba, 0x19, 0xbb, 0x34, 0x06,
    0xb1, 0xbb, 0x10, 0x1a, 0xe3, 0x6f, 0x9b, 0x53, 0x84, 0x5b, 0xbc, 0x19, 0xf9, 0xb2, 0x19, 0xfd,
    0x09, 0x7e, 0xf9, 0x61, 0x37, 0xfe, 0xa5, 0xf3, 0xb8, 0x85, 0xcb, 0x70, 0xcd, 0x1a, 0xef, 0x10,
    0x77, 0x43, 0xd7, 0xdd, 0x9b, 0xda, 0x1b, 0xb2, 0x18, 0x7b, 0x6a, 0x8c, 0x3d, 0xed, 0x9f, 0x7b,
    0xda, 0x8d, 0x1e, 0x8c, 0x15, 0x01, 0xb0, 0xed, 0x06, 0x3c, 0xe1, 0xbb, 0xb1, 0xa7, 0x6e, 0x1d,
    0xef, 0xc0, 0xcd, 0x79, 0xc6, 0x78, 0xf8, 0x66, 0x8c, 0x98, 0xb0, 0x3a, 0x78, 0x36, 0x32, 0xb8,
    0x59, 0xea, 0x01, 0x7d, 0x30, 0xc4, 0x19, 0xe3, 0x0c, 0xe2, 0xee, 0x19, 0x8e, 0x0c, 0x49, 0xc6,
    0x0e, 0xc6, 0xf1, 0xdd, 0xd8, 0xf0, 0xa7, 0xd8, 0x68, 0xcb, 0x46, 0x71, 0xc5, 0xb0, 0x01, 0xb8,
    0x83, 0x1b, 0x05, 0x5e, 0x43, 0x97, 0x67, 0x56, 0xea, 0x2d, 0xca, 0xf5, 0xfb, 0x37, 0x17, 0x14,
    0x48, 0x93, 0x35, 0x86, 0x82, 0x21, 0xe8, 0xa0, 0x01, 0x82, 0x41, 0x74, 0x78, 0x86, 0x2e, 0xcf,
    0x40, 0xf8, 0x36, 0x7c, 0x7d, 0x81, 0x5c, 0x7e, 0x00, 0x0e, 0xb4, 0x38, 0xc8, 0x4c, 0x16, 0xd0,
    0xbe, 0x3d, 0x2f, 0x07, 0x6d, 0x5a, 0x38, 0x71, 0x6b, 0xd6, 0x7a, 0xa6, 0xae, 0x99, 0xb6, 0x9b,
    0x3b, 0x3a, 0x44, 0x58, 0xa8, 0xb7, 0xd9, 0x3d, 0xa3, 0x86, 0x33, 0x7b, 0x04, 0x60, 0x00, 0x67,
    0x28, 0xad, 0xd9, 0x60, 0xe1, 0xd5, 0x40, 0x3f, 0x5c, 0x8c, 0xf7, 0xb1, 0xa9, 0xee, 0xa6, 0xe2,
    0x11, 0x16, 0x83, 0x87, 0x43, 0x68, 0x8c, 0x62, 0xd3, 0x0d, 0x8d, 0x11, 0xce, 0xe2, 0xd0, 0xc0,
    0x00, 0x34, 0x30, 0x08, 0x5a, 0x74, 0x85, 0x93, 0xb6, 0xf0, 0x4e, 0x68, 0x24, 0xe6, 0xcd, 0x26,
    0x07, 0xcc, 0x53, 0x10, 0x26, 0x50, 0x10, 0x18, 0x76, 0x10, 0xad, 0xbb, 0xa9, 0x85, 0x93, 0xba,
    0x9b, 0xeb, 0x29, 0x28, 0x9a, 0xea, 0xc0, 0x49, 0xdb, 0x43, 0xd6, 0x10, 0xd6, 0x06, 0x95, 0xdf,
    0x8f, 0x33, 0x7a, 0x97, 0xea, 0x4a, 0x66, 0xaa, 0x03, 0x37, 0xce, 0x50, 0x32, 0x8c, 0x32, 0x9f,
    0x99, 0x02, 0xbd, 0xf3, 0xa0, 0x68, 0xa5, 0x81, 0x19, 0x67, 0x6d, 0xe1, 0x12, 0xc6, 0x59, 0x53,
    0x76, 0x22, 0xd7, 0x5a, 0x9b, 0x4a, 0x2a, 0x34, 0x82, 0x16, 0xad, 0x39, 0xc0, 0x42, 0xdb, 0x60,
    0xd9, 0x4d, 0x0f, 0x68, 0xd5, 0x40, 0xf7, 0x42, 0x03, 0x9c, 0xd0, 0x40, 0x17, 0x34, 0x70, 0x92,
    0x82, 0xec, 0xd5, 0x36, 0x3a, 0xfb, 0x80, 0x11, 0xd6, 0x46, 0xd5, 0xb6, 0x0b, 0x67, 0xdc, 0x6d,
    0x9a, 0x70, 0x86, 0x41, 0x72, 0x44, 0xae, 0x0f, 0x00, 0x59, 0xa1, 0xc2, 0x91, 0x52, 0x05, 0x52,
    0x1f, 0xc0, 0xae, 0xcd, 0xbe, 0x01, 0x30, 0x50, 0xb1, 0x4c, 0xac, 0x61, 0xe9, 0x4c, 0xd6, 0xb6,
    0x88, 0x69, 0x1b, 0xb0, 0x04, 0x1a, 0xe9, 0xa0, 0x05, 0x67, 0x0e, 0x30, 0xb7, 0xd5, 0x5a, 0xb5,
    0x6d, 0x2e, 0xdd, 0x51, 0x61, 0x5a, 0x15, 0x67, 0x92, 0x46, 0xbb, 0x19, 0x2b, 0x82, 0x16, 0x64,
    0x66, 0xda, 0xd1, 0x9a, 0xc5, 0x59, 0x03, 0x13, 0xa1, 0xc1, 0xd1, 0xf6, 0x0c, 0x34, 0xe6, 0xdb,
    0x1d, 0x10, 0x40, 0x0b, 0xd6, 0x40, 0x17, 0xb6, 0x7f, 0x0e, 0x1a, 0xa0, 0x24, 0x14, 0xf0, 0x40,
    0x23, 0x6d, 0xcd, 0xa6, 0x71, 0x36, 0x64, 0x57, 0xe4, 0xd5, 0x3c, 0x73, 0x81, 0x3c, 0xc5, 0x1a,
    0xc3, 0x0d, 0x50, 0x58, 0x03, 0x5d, 0xd0, 0x88, 0xb0, 0x46, 0x3a, 0x68, 0xd3, 0xd6, 0x2c, 0xad,
    0x77, 0x3a, 0x2d, 0x3b, 0x71, 0xcd, 0x6b, 0xa8, 0x40, 0x2e, 0xc2, 0x33, 0x86, 0xa1, 0xd1, 0xa9,
    0x07, 0xa1, 0x9a, 0x56, 0xab, 0xb6, 0x5d, 0x35, 0xed, 0x12, 0xd6, 0xe0, 0x9a, 0x8a, 0x99, 0xec,
    0x54, 0xf2, 0x6a, 0x5a, 0x08, 0x96, 0x54, 0xe9, 0x52, 0x04, 0x1a, 0x41, 0x1b, 0xca, 0x4e, 0x80,
    0xb2, 0x9c, 0x2a, 0x4a, 0xf8, 0x83, 0xd2, 0xbd, 0xb8, 0x4b, 0xf7, 0xf4, 0x0d, 0x58, 0x5e, 0xb8,
    0x00, 0xbc, 0x37, 0x15, 0xe1, 0xc2, 0x25, 0x0c, 0x0d, 0x9c, 0xd4, 0x69, 0x4d, 0x35, 0x6d, 0xa8,
    0xad, 0x56, 0x1a, 0xfe, 0xe2, 0x6e, 0xf8, 0x97, 0x4a, 0x11, 0x5a, 0xc3, 0x1f, 0x93, 0x6f, 0x84,
    0x86, 0xdf, 0x8c, 0xb3, 0xd1, 0x39, 0x84, 0x29, 0x09, 0xbf, 0x05, 0x2d, 0xcc, 0xb0, 0x86, 0x36,
    0x5c, 0x30, 0x33, 0xed, 0xb4, 0x4c, 0x28, 0x54, 0x8f, 0x25, 0x53, 0xc2, 0x07, 0x97, 0xb4, 0xaa,
    0x88, 0xba, 0x65, 0x5a, 0xf4, 0x6d, 0x0b, 0xe4, 0xe9, 0xde, 0x69, 0x4a, 0x8a, 0x18, 0x50, 0x50,
    0x99, 0x1e, 0x15, 0x59, 0xa5, 0x68, 0xd3, 0xa8, 0x08, 0x84, 0x0d, 0x30, 0x8d, 0x3d, 0x52, 0x85,
    0xf2, 0xb3, 0x24, 0xfc, 0xc4, 0x69, 0x35, 0x04, 0xa6, 0xd5, 0xe9, 0x83, 0x3f, 0x16, 0x67, 0x25,
    0x61, 0x54, 0x34, 0x5d, 0xd3, 0x0a, 0xc5, 0x4b, 0x71, 0x8d, 0x71, 0x35, 0xf4, 0x87, 0x06, 0xcc,
    0x00, 0x09, 0xa3, 0x6f, 0x80, 0x45, 0x43, 0xf9, 0xb5, 0x14, 0x04, 0xfa, 0x81, 0x19, 0xb3, 0x67,
    0xad, 0x82, 0x3c, 0x7d, 0x60, 0x26, 0x14, 0x4e, 0xe9, 0x81, 0x2e, 0xdc, 0xb2, 0xfd, 0xc0, 0x8c,
    0x7a, 0x94, 0x07, 0x83, 0x47, 0x79, 0xb4, 0x4e, 0x64, 0xfa, 0xc0, 0x4c, 0xee, 0xc1, 0xac, 0xd4,
    0x51, 0x51, 0xc6, 0xb4, 0xba, 0xf9, 0x50, 0xea, 0x31, 0x3b, 0xc8, 0x3b, 0x66, 0x67, 0xfd, 0xd8,
    0x92, 0xfa, 0x6c, 0x49, 0xe5, 0x98, 0x7e, 0x2c, 0x05, 0x20, 0x71, 0x8a, 0xa8, 0x49, 0x82, 0xb3,
    0x43, 0x2c, 0xc8, 0x3c, 0xe5, 0x85, 0x29, 0xa7, 0xbc, 0x46, 0xd2, 0xaa, 0x9b, 0x1c, 0xb5, 0x83,
    0x59, 0xee, 0x5a, 0x43, 0x6a, 0x5e, 0xcd, 0x4d, 0x85, 0x55, 0x8e, 0x76, 0x09, 0xe5, 0xda, 0xa4,
    0xc2, 0xaf, 0x52, 0x09, 0xbb, 0x89, 0x31, 0x3a, 0x00, 0x08, 0xf1, 0x59, 0x24, 0x9c, 0x5c, 0xe7,
    0xcf, 0xa6, 0xb2, 0x93, 0xa6, 0x14, 0xcc, 0x81, 0x16, 0x13, 0x41, 0x6b, 0x22, 0xc6, 0x91, 0x48,
    0xe2, 0x05, 0x2d, 0x58, 0x41, 0x0b, 0x9a, 0x11, 0x27, 0xce, 0x30, 0x8c, 0x33, 0x6f, 0x04, 0xe0,
    0x72, 0xa6, 0x4d, 0xcb, 0x4e, 0x38, 0x66, 0xda, 0xa2, 0x81, 0x16, 0xad, 0xa0, 0x55, 0xab, 0xec,
    0xe5, 0xbb, 0x99, 0x1a, 0x01, 0x68, 0xec, 0x9f, 0xc4, 0xcf, 0x7f, 0x85, 0xb4, 0x0d, 0x41, 0xf5,
    0xe0, 0xbc, 0xfa, 0x6c, 0x2d, 0x6d, 0xcf, 0xd6, 0x1a, 0xe9, 0x79, 0x33, 0x45, 0x8c, 0x43, 0x63,
    0xa0, 0xb3, 0x39, 0x00, 0x93, 0x22, 0x00, 0x97, 0xac, 0x19, 0x1a, 0x29, 0x1b, 0x13, 0x5a, 0x44,
    0xc8, 0x6b, 0x11, 0x31, 0x48, 0x8e, 0xcb, 0xc2, 0xc9, 0xa0, 0xab, 0xd9, 0x40, 0x6b, 0xf5, 0xcc,
    0x94, 0x84, 0x57, 0x26, 0x14, 0xca, 0x2c, 0xa9, 0x60, 0xaa, 0xa4, 0x4a, 0xa7, 0x6d, 0x8d, 0x1c,
    0x43, 0xd9, 0x09, 0x84, 0xe3, 0x02, 0x8f, 0xcf, 0x4e, 0xb9, 0xb1, 0x49, 0x77, 0xff, 0xf7, 0xb3,
    0x4f, 0xbe, 0x49, 0xd5, 0x69, 0x3d, 0xa7, 0x6f, 0xce, 0xdf, 0x00, 0x4f, 0xa0, 0x7b, 0x3d, 0xa3,
    0xb4, 0x40, 0x07, 0x4b, 0x69, 0xb0, 0x6c, 0xcd, 0x70, 0x92, 0x35, 0xf0, 0x94, 0x40, 0x4f, 0x85,
    0x46, 0xfa, 0xb9, 0xed, 0x75, 0x52, 0x04, 0x19, 0x4a, 0x83, 0xe5, 0x6b, 0xb6, 0x44, 0x75, 0x4f,
    0xdd, 0xcd, 0xee, 0xdb, 0xe9, 0x6b, 0xa0, 0x20, 0x9a, 0xa4, 0xa0, 0xf4, 0xdb, 0xa4, 0xc1, 0xe3,
    0x31, 0x4c, 0xdb, 0x7f, 0x3b, 0x0d, 0xde, 0x3b, 0xcf, 0x33, 0xe9, 0xdb, 0x69, 0xe0, 0xf5, 0xfa,
    0xdd, 0xe4, 0xbe, 0xf1, 0xc5, 0x13, 0xda, 0xfe, 0xe3, 0x3d, 0xbd, 0x7b, 0xbd, 0x1c, 0x67, 0x74,
    0xdc, 0x45, 0xe2, 0x70, 0x46, 0x0f, 0x89, 0x00, 0xe2, 0x3d, 0x94, 0x31, 0xd6, 0x1a, 0xa3, 0x31,
    0x60, 0x49, 0x03, 0x2e, 0x9d, 0x56, 0xb8, 0xdc, 0x79, 0xb2, 0x43, 0x03, 0xb4, 0x60, 0xff, 0xf4,
    0x14, 0x04, 0x99, 0x14, 0x44, 0x6e, 0x0a, 0x1a, 0xf1, 0x18, 0x59, 0x78, 0xed, 0x94, 0x84, 0x42,
    0x0a, 0x68, 0x67, 0xa0, 0x41, 0x69, 0xac, 0xa1, 0xbd, 0xe7, 0x0b, 0x74, 0xba, 0xdf, 0xcd, 0xc7,
    0x44, 0x80, 0xb0, 0xf5, 0xd5, 0x94, 0xee, 0x4a, 0x20, 0x94, 0xe8, 0xf4, 0xdd, 0xa4, 0x60, 0xa0,
    0x93, 0x27, 0x36, 0x5b, 0x3e, 0x73, 0x95, 0x07, 0x91, 0xd8, 0x3c, 0xb7, 0xdf, 0x9c, 0x8a, 0x4d,
    0x9a, 0x4c, 0xc2, 0xb4, 0x84, 0x82, 0x48, 0x8f, 0x4d, 0x53, 0x12, 0x26, 0x4b, 0x38, 0xed, 0xf6,
    0x86, 0xf5, 0x9b, 0x5a, 0x52, 0x91, 0x10, 0x9b, 0xf4, 0xb0, 0x92, 0xea, 0x70, 0xdb, 0x64, 0xc8,
    0x99, 0x5a, 0x38, 0x91, 0x90, 0xea, 0x68, 0x32, 0x9c, 0x68, 0x2a, 0x9c, 0x48, 0xd9, 0xcd, 0x8f,
    0x91, 0x9d, 0xfa, 0x6a, 0x7b, 0x2e, 0x3b, 0x41, 0x20, 0x3b, 0x51, 0xb0, 0x0c, 0x25, 0xab, 0x67,
    0x1c, 0xce, 0x66, 0x13, 0x4a, 0x4d, 0x8b, 0x00, 0x15, 0x12, 0x1a, 0x39, 0x7a, 0x23, 0x80, 0xcc,
    0x11, 0x40, 0x47, 0xd6, 0x08, 0x47, 0x80, 0x09, 0x63, 0x12, 0x9f, 0x79, 0x73, 0x00, 0x9d, 0x16,
    0x4e, 0x07, 0x94, 0x77, 0x19, 0xdd, 0x8c, 0xb3, 0x68, 0x23, 0xe6, 0x29, 0xa9, 0x28, 0x25, 0x02,
    0x46, 0x9e, 0x45, 0x69, 0x1b, 0xd2, 0x68, 0xfb, 0x39, 0x32, 0xab, 0x5b, 0xd7, 0xa0, 0x60, 0xe1,
    0x42, 0xa7, 0xb1, 0x06, 0x43, 0xdb, 0xf0, 0x38, 0xda, 0x5e, 0xaa, 0x1e, 0x74, 0x17, 0xd7, 0x94,
    0x86, 0x5f, 0x12, 0x96, 0xce, 0x05, 0x2d, 0x05, 0x6b, 0x0d, 0x72, 0x32, 0x6d, 0x0d, 0x77, 0xc2,
    0x87, 0x0b, 0x18, 0x3e, 0x73, 0xe3, 0x6c, 0x2a, 0x07, 0x2c, 0xa9, 0xcf, 0xe8, 0x58, 0x1e, 0x54,
    0x53, 0xcf, 0x69, 0x09, 0x74, 0x4e, 0x71, 0x99, 0xd1, 0x82, 0x62, 0xcd, 0x6b, 0xfb, 0xb8, 0xfd,
    0x7b, 0xc7, 0xd4, 0x3d, 0x57, 0xe9, 0x76, 0x8d, 0xbd, 0xd3, 0x5c, 0x15, 0xe4, 0x11, 0x7d, 0xcd,
    0x2d, 0xa2, 0xc4, 0x67, 0xae, 0x16, 0x31, 0x25, 0x9c, 0xd8, 0x20, 0x66, 0x04, 0x4c, 0x11, 0xb4,
    0xa4, 0x87, 0x10, 0x91, 0x21, 0xb4, 0x68, 0x39, 0x68, 0x99, 0x70, 0xa2, 0x50, 0x38, 0x7d, 0xec,
    0x46, 0xec, 0x70, 0x21, 0xe9, 0x38, 0x5b, 0x4b, 0xdb, 0x4b, 0x74, 0x5a, 0x2f, 0xce, 0xcc, 0x1d,
    0xca, 0x0d, 0x1a, 0xd5, 0xa2, 0x56, 0x15, 0x85, 0x05, 0x47, 0x9a, 0xa3, 0x0b, 0x1a, 0x1a, 0x68,
    0x63, 0xd0, 0x80, 0x00, 0x34, 0x44, 0x4e, 0xa3, 0x31, 0x68, 0xc9, 0x19, 0x4e, 0x35, 0x2f, 0x6f,
    0x42, 0x30, 0xd0, 0x0d, 0x85, 0xdf, 0x34, 0x05, 0xd5, 0x69, 0x0a, 0xd2, 0xc4, 0x38, 0x57, 0x53,
    0x61, 0xc5, 0x19, 0x2d, 0xc7, 0x59, 0x9a, 0x4e, 0x3b, 0xdc, 0xc5, 0x81, 0x7a, 0x60, 0x6a, 0x2a,
    0xba, 0x0b, 0xc9, 0x54, 0x49, 0x7e, 0x8e, 0x54, 0x47, 0x72, 0x87, 0x52, 0x47, 0xeb, 0xa5, 0x06,
    0xba, 0x75, 0x86, 0x42, 0x5e, 0x3e, 0x6b, 0x37, 0x20, 0x8c, 0xb3, 0xa6, 0xec, 0xa4, 0xca, 0x94,
    0xa0, 0x66, 0x91, 0x84, 0x94, 0x35, 0x23, 0x8f, 0x48, 0x62, 0x09, 0x27, 0xb3, 0x4a, 0x65, 0x05,
    0xad, 0x4b, 0x3d, 0x98, 0x6a, 0x5e, 0xc9, 0xa9, 0x05, 0x51, 0xa0, 0xda, 0xae, 0x79, 0xd5, 0x36,
    0x05, 0x5b, 0x44, 0x41, 0xdb, 0xa8, 0xaa, 0xa6, 0x61, 0xc1, 0x19, 0x57, 0xec, 0x99, 0x70, 0x36,
    0x98, 0x22, 0x92, 0x79, 0x8a, 0x38, 0x1a, 0x45, 0xd6, 0xd7, 0x7b, 0x64, 0xc3, 0xe9, 0x70, 0x9d,
    0x06, 0x0d, 0x29, 0xd0, 0x43, 0xac, 0x31, 0xaa, 0x35, 0x62, 0xd9, 0x89, 0x02, 0xd9, 0x29, 0x7d,
    0x8c, 0x2b, 0x64, 0xec, 0xea, 0x86, 0xc6, 0x00, 0xb4, 0x14, 0x02, 0x6d, 0x4a, 0x4d, 0x4b, 0x96,
    0x02, 0x46, 0xf9, 0x1c, 0x58, 0x70, 0xc6, 0xb1, 0x86, 0x8a, 0x33, 0x12, 0x22, 0xa0, 0x6d, 0x2a,
    0x6a, 0x94, 0x69, 0xb5, 0x89, 0x58, 0x8c, 0x35, 0x20, 0xc0, 0x1a, 0x10, 0x64, 0x8d, 0xf3, 0xdb,
    0x1d, 0xad, 0x40, 0x36, 0x57, 0xdb, 0xa9, 0xd0, 0x00, 0x25, 0xa1, 0x80, 0x07, 0x1a, 0x53, 0x33,
    0x14, 0xa5, 0x2e, 0xab, 0xd5, 0x52, 0xa7, 0x2d, 0x05, 0x6d, 0xca, 0x6d, 0x2a, 0x1b, 0x40, 0xa1,
    0x0d, 0x20, 0xe7, 0xa4, 0x82, 0xdc, 0xa0, 0xa5, 0x20, 0x68, 0xd3, 0xd6, 0x2c, 0x3d, 0xd0, 0xd3,
    0x0a, 0x97, 0x54, 0xcf, 0x44, 0xda, 0x86, 0x20, 0x6d, 0xb3, 0xdb, 0x4f, 0x4e, 0x68, 0x28, 0xa9,
    0x8e, 0x42, 0xa9, 0x6e, 0x39, 0x34, 0x46, 0x0a, 0xf2, 0x39, 0xd9, 0x89, 0x82, 0x14, 0xe4, 0x1d,
    0x62, 0x51, 0xca, 0x10, 0x6b, 0xea, 0xdc, 0x36, 0xbb, 0xd0, 0xe4, 0x28, 0x90, 0xd5, 0xd2, 0x1d,
    0x02, 0xa5, 0x7b, 0x4a, 0x53, 0x71, 0x2a, 0x6b, 0xa4, 0xd4, 0xb4, 0x61, 0x68, 0xd0, 0x58, 0xc2,
    0x87, 0x50, 0xf3, 0x4a, 0xce, 0x92, 0xca, 0x75, 0x02, 0x33, 0x7c, 0xc4, 0x62, 0xa9, 0x14, 0xa1,
    0x8d, 0x3d, 0x62, 0xf2, 0x8d, 0xb0, 0x9b, 0xee, 0x33, 0x2e, 0x53, 0xc2, 0x12, 0xbb, 0xf5, 0xd1,
    0xd1, 0x77, 0x9a, 0x18, 0x47, 0x41, 0x68, 0xac, 0x9d, 0xee, 0x0c, 0x81, 0x4b, 0x4e, 0x69, 0xd5,
    0x7a, 0x3c, 0xe0, 0x63, 0x14, 0xc8, 0xe9, 0xd9, 0x29, 0x2c, 0xe1, 0xa7, 0x0f, 0x17, 0xd2, 0xc6,
    0x1e, 0xe0, 0x40, 0xff, 0x63, 0x8e, 0x58, 0x7c, 0xbc, 0x69, 0xf5, 0x80, 0x66, 0x62, 0x83, 0xbf,
    0x68, 0xaa, 0x5b, 0xdf, 0xee, 0x90, 0x53, 0xdb, 0x36, 0x95, 0xee, 0xbd, 0x67, 0xa1, 0x01, 0x73,
    0x1a, 0x68, 0xc5, 0xb2, 0x89, 0x72, 0x4f, 0x79, 0xa5, 0x52, 0x10, 0xa4, 0x4d, 0x11, 0xb5, 0x69,
    0xf5, 0xfa, 0x70, 0xfa, 0x78, 0xa9, 0xce, 0x92, 0xce, 0x42, 0x47, 0x79, 0xa6, 0x0f, 0x19, 0x19,
    0x70, 0x06, 0x1f, 0xf6, 0x60, 0xd6, 0xfc, 0xa8, 0xa8, 0xb1, 0x9c, 0x7a, 0xcc, 0x8e, 0xf2, 0x8e,
    0xd9, 0x59, 0x7f, 0x3e, 0x7d, 0xde, 0x84, 0xb4, 0x53, 0x5e, 0xa9, 0xe4, 0x08, 0xa4, 0x08, 0x97,
    0x1a, 0x34, 0x3a, 0x89, 0x8b, 0x84, 0xf7, 0xed, 0x07, 0xb3, 0x6e, 0x98, 0xba, 0xee, 0x1b, 0x70,
    0xd5, 0x5a, 0x9e, 0x8b, 0x02, 0xd8, 0x6b, 0xf3, 0xfb, 0xab, 0x60, 0xf0, 0xcd, 0xf0, 0x85, 0xf1,
    0xaa, 0x35, 0x54, 0x18, 0x63, 0xbd, 0x41, 0xd1, 0xb3, 0x76, 0x4d, 0xb6, 0x8b, 0xb0, 0x59, 0xb3,
    0xff, 0x3a, 0x63, 0xfd, 0xda, 0xdd, 0x79, 0x46, 0x8d, 0x07, 0xed, 0x3f, 0x7d, 0x51, 0xff, 0x85,
    0xbf, 0xff, 0xe9, 0xbe, 0xe4, 0xf6, 0xb8, 0x5b, 0xbb, 0xcb, 0xfe, 0x17, 0xec, 0xbc, 0x6b, 0xd7,
    0xaa, 0xdd, 0xa4, 0xca, 0x78, 0xf7, 0x06, 0x95, 0x4b, 0x87, 0x99, 0xca, 0xac, 0x21, 0x32, 0x6b,
    0xca, 0xee, 0xac, 0xb4, 0x01, 0xad, 0x27, 0xd8, 0x79, 0x4e, 0xda, 0x06, 0xf4, 0x88, 0xae, 0x8d,
    0x57, 0x68, 0x88, 0xd7, 0x57, 0xd0, 0x7e, 0x0b, 0xdf, 0x8f, 0x04, 0xdf, 0xf6, 0x96, 0xae, 0x03,
    0xd9, 0x8b, 0x36, 0x3b, 0x97, 0xfb, 0x10, 0xbc, 0xbb, 0x1d, 0x6c, 0x3e, 0x8c, 0x9a, 0x46, 0xbb,
    0x3d, 0x95, 0xed, 0xd5, 0x37, 0xf0, 0x9d, 0xa4, 0xda, 0x91, 0x22, 0x43, 0xbf, 0xbc, 0xde, 0xae,
    0xdf, 0x5e, 0xfc, 0x2f, 0xc0, 0x00, 0x2f, 0x06, 0x07, 0xa1, 0x83, 0x44, 0x43, 0x34, 0x00, 0x00,
    0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
};

@interface ZBarCropMaskLayer ()
{
    CALayer* lineLayer;
    CGFloat step;
    CGFloat offsetX;
}

@property (strong, nonatomic) CADisplayLink* timer;

@end

#define LineHeight 13.0f

@implementation ZBarCropMaskLayer

@synthesize timer = _timer;
@synthesize hollowRect = _hollowRect;

- (id) init
{
    self = [super init];
    if (self)
    {
        _timer = [CADisplayLink displayLinkWithTarget:self selector:@selector(onTimer)];
        [_timer addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
        
        offsetX = 0;
        step = 0;
        UIImage* image = [[UIImage imageWithData:[NSData dataWithBytes:lineImagebytes length:sizeof(lineImagebytes)]] retain];
        
        lineLayer = [CALayer new];
        [lineLayer setBackgroundColor:[UIColor colorWithRed:1 green:0 blue:0 alpha:.5].CGColor];
        [lineLayer setBackgroundColor:[UIColor clearColor].CGColor];
        [lineLayer setContents:(id)[image CGImage]];
    }
    return self;
}

- (void) dealloc
{
    [_timer invalidate];
    [_timer release];
    _timer = nil;
    
    [lineLayer removeFromSuperlayer];
    [lineLayer release];
    lineLayer = nil;
    
    [super dealloc];
}

- (void) setHollowRect:(CGRect)hollowRect
{
    _hollowRect = hollowRect;
    [lineLayer setFrame:CGRectMake(_hollowRect.origin.x + offsetX, _hollowRect.origin.y, LineHeight, _hollowRect.size.height)];
    
    NSLog(@"enter setHollowRect %@", NSStringFromCGRect(_hollowRect));
    step = 1;
    [self addSublayer:lineLayer];
}

- (void) onTimer
{
    if (offsetX >= _hollowRect.size.width)
    {
        step = -3;
    }
    else if (offsetX <= -LineHeight)
    {
        step = 3;
    }
    
    offsetX += step;
    
    [lineLayer setFrame:CGRectMake(_hollowRect.origin.x + offsetX, _hollowRect.origin.y, LineHeight, _hollowRect.size.height)];
}

- (void) drawInContext:(CGContextRef)ctx
{
    CGRect rect = self.hollowRect;
    
    // draw four rect around the crop area, appear a hollow effective
    CGContextSetFillColorWithColor(ctx, [UIColor colorWithWhite:.0 alpha:.6].CGColor);
    
    CGFloat x = rect.origin.x;
    CGFloat y = rect.origin.y;
    CGFloat w = rect.size.width;
    CGFloat h = rect.size.height;
    
    CGFloat fw = self.bounds.size.width;
    CGFloat fh = self.bounds.size.height;
    
    CGContextAddRect(ctx, CGRectMake(0, 0, fw, y));
    CGContextAddRect(ctx, CGRectMake(0, y, x, h));
    CGContextAddRect(ctx, CGRectMake(x + w, y, fw - x - w, h));
    CGContextAddRect(ctx, CGRectMake(0, y + h, fw, fh - y - h));
    
    CGContextFillPath(ctx);
    CGContextStrokePath(ctx);
    
    // draw four corner
    CGFloat s = 26;
    CGFloat f = 5;
    
    CGContextSetFillColorWithColor(ctx, [UIColor colorWithRed:0 green:1 blue:0 alpha:1.0].CGColor);
    
    CGPoint c = CGPointMake(x, y);
    CGContextMoveToPoint(ctx, c.x, c.y);
    CGContextAddLineToPoint(ctx, c.x + s, c.y);
    CGContextAddLineToPoint(ctx, c.x + s, c.y + f);
    CGContextAddLineToPoint(ctx, c.x + f, c.y + f);
    CGContextAddLineToPoint(ctx, c.x + f, c.y + s);
    CGContextAddLineToPoint(ctx, c.x, c.y + s);
    CGContextAddLineToPoint(ctx, c.x, c.y);
    CGContextFillPath(ctx);
    CGContextStrokePath(ctx);
    
    c = CGPointMake(x, y + h);
    CGContextMoveToPoint(ctx, c.x, c.y);
    CGContextAddLineToPoint(ctx, c.x + s, c.y);
    CGContextAddLineToPoint(ctx, c.x + s, c.y - f);
    CGContextAddLineToPoint(ctx, c.x + f, c.y - f);
    CGContextAddLineToPoint(ctx, c.x + f, c.y - s);
    CGContextAddLineToPoint(ctx, c.x, c.y - s);
    CGContextAddLineToPoint(ctx, c.x, c.y);
    CGContextFillPath(ctx);
    CGContextStrokePath(ctx);
    
    
    c = CGPointMake(x + w, y);
    CGContextMoveToPoint(ctx, c.x, c.y);
    CGContextAddLineToPoint(ctx, c.x - s, c.y);
    CGContextAddLineToPoint(ctx, c.x - s, c.y + f);
    CGContextAddLineToPoint(ctx, c.x - f, c.y + f);
    CGContextAddLineToPoint(ctx, c.x - f, c.y + s);
    CGContextAddLineToPoint(ctx, c.x, c.y + s);
    CGContextAddLineToPoint(ctx, c.x, c.y);
    CGContextFillPath(ctx);
    CGContextStrokePath(ctx);
    
    c = CGPointMake(x + w, y + h);
    CGContextMoveToPoint(ctx, c.x, c.y);
    CGContextAddLineToPoint(ctx, c.x - s, c.y);
    CGContextAddLineToPoint(ctx, c.x - s, c.y - f);
    CGContextAddLineToPoint(ctx, c.x - f, c.y - f);
    CGContextAddLineToPoint(ctx, c.x - f, c.y - s);
    CGContextAddLineToPoint(ctx, c.x, c.y - s);
    CGContextAddLineToPoint(ctx, c.x, c.y);
    CGContextFillPath(ctx);
    CGContextStrokePath(ctx);
    
    
//    CGRect ovalRect = CGRectMake(x + offsetX, y, 2, h);
//    [image drawInRect:_hollowRect];
    
//    self.contents = (id)[image CGImage];
//    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:ovalRect];
//    CGContextAddPath(ctx, path.CGPath);
//    CGContextSetRGBFillColor(ctx, 0, 1, 0, .8f);
//    CGContextSetShadowWithColor(ctx, CGSizeMake(1.0f, 1.0f), 0.f, [[UIColor colorWithRed:0 green:1 blue:0 alpha:.8f] CGColor]);
//    CGContextEOFillPath(ctx);
}

@end

// silence warning
@interface ZBarReaderViewImpl : NSObject
@end

@implementation ZBarReaderView

@synthesize readerDelegate, tracksSymbols, trackingColor, torchMode, showsFPS,
    zoom, maxZoom, scanCrop, previewTransform, captureReader;
@dynamic scanner, allowsPinchZoom, enableCache, device, session;

+ (id) alloc
{
    if(self == [ZBarReaderView class]) {
        // this is an abstract wrapper for implementation selected
        // at compile time.  replace with concrete subclass.
        return ([ZBarReaderViewImpl alloc]);
    }
    return([super alloc]);
}

- (void) initSubviews
{
    assert(preview);

    overlay = [ZBarCropMaskLayer new];
    overlay.backgroundColor = [UIColor clearColor].CGColor;
    [preview addSublayer: overlay];

#ifndef NDEBUG
    overlay.borderWidth = 2;
    overlay.borderColor = [UIColor colorWithRed: 0
                                   green: 0
                                   blue: 1
                                   alpha: .5].CGColor;

    cropLayer = [CALayer new];
    cropLayer.backgroundColor = [UIColor clearColor].CGColor;
    cropLayer.borderWidth = .5;
    cropLayer.borderColor = [UIColor colorWithRed: 1
                                     green: 1
                                     blue: 1
                                     alpha: .5].CGColor;
    [overlay addSublayer: cropLayer];
#endif

    tracking = [CALayer new];
    tracking.opacity = 0;
    tracking.borderWidth = 1;
    tracking.backgroundColor = [UIColor clearColor].CGColor;
    [overlay addSublayer: tracking];

    trackingColor = [[UIColor greenColor]
                        retain];
    tracking.borderColor = trackingColor.CGColor;
    
    
//    cropMaskView = [ZBarCropMaskView new];
//    cropMaskView.backgroundColor = [UIColor clearColor];
//    [self addSubview:cropMaskView];
    
    fpsView = [UIView new];
    fpsView.backgroundColor = [UIColor colorWithWhite: 0
                                       alpha: .333];
    fpsView.layer.cornerRadius = 12;
    fpsView.hidden = YES;
    [self addSubview: fpsView];

    fpsLabel = [[UILabel alloc]
                   initWithFrame: CGRectMake(0, 0, 80, 32)];
    fpsLabel.backgroundColor = [UIColor clearColor];
    fpsLabel.textColor = [UIColor colorWithRed: .333
                                  green: .666
                                  blue: 1
                                  alpha: 1];
    fpsLabel.font = [UIFont systemFontOfSize: 18];
    fpsLabel.textAlignment = UITextAlignmentRight;
    [fpsView addSubview: fpsLabel];

//    self.zoom = 1.25;
    self.zoom = 1.0;
}

- (void) _initWithImageScanner: (ZBarImageScanner*) scanner
{
    assert(scanner);

    tracksSymbols = YES;
    interfaceOrientation = UIInterfaceOrientationPortrait;
    torchMode = 2; // AVCaptureTorchModeAuto
    scanCrop = effectiveCrop = CGRectMake(0, 0, 1, 1);
    imageScale = 1;
    previewTransform = CGAffineTransformIdentity;
    maxZoom = 2;

    pinch = [[UIPinchGestureRecognizer alloc]
                initWithTarget: self
                action: @selector(handlePinch)];
    [self addGestureRecognizer: pinch];
}

- (id) initWithImageScanner: (ZBarImageScanner*) scanner
{
    self = [super initWithFrame: CGRectMake(0, 0, 320, 426)];
    if(!self)
        return(nil);

    self.backgroundColor = [UIColor blackColor];
    self.contentMode = UIViewContentModeScaleAspectFill;
    self.clipsToBounds = YES;
    self.autoresizingMask =
        UIViewAutoresizingFlexibleWidth |
        UIViewAutoresizingFlexibleHeight;

    [self _initWithImageScanner: scanner];
    return(self);
}

- (id) init
{
    ZBarImageScanner *scanner =
        [[ZBarImageScanner new]
            autorelease];
    self = [self initWithImageScanner: scanner];
    if(!self)
        return(nil);

    [scanner setSymbology: 0
             config: ZBAR_CFG_X_DENSITY
             to: 3];
    [scanner setSymbology: 0
             config: ZBAR_CFG_Y_DENSITY
             to: 3];
    return(self);
}

- (id) initWithCoder: (NSCoder*) decoder
{
    self = [super initWithCoder: decoder];
    if(!self)
        return(nil);
    ZBarImageScanner *scanner =
        [[ZBarImageScanner new]
            autorelease];
    [self _initWithImageScanner: scanner];

    [scanner setSymbology: 0
             config: ZBAR_CFG_X_DENSITY
             to: 3];
    [scanner setSymbology: 0
             config: ZBAR_CFG_Y_DENSITY
             to: 3];
    return(self);
}

- (void) dealloc
{
    [preview removeFromSuperlayer];
    [preview release];
    preview = nil;
    [overlay release];
    overlay = nil;
    [cropLayer release];
    cropLayer = nil;
    [tracking release];
    tracking = nil;
    [trackingColor release];
    trackingColor = nil;
    [fpsLabel release];
    fpsLabel = nil;
    [fpsView release];
    fpsView = nil;
    [pinch release];
    pinch = nil;
    [super dealloc];
}

- (void) resetTracking
{
    [tracking removeAllAnimations];
    [CATransaction begin];
    [CATransaction setDisableActions: YES];
    CGSize size = overlay.bounds.size;
    CGRect crop = effectiveCrop;
    tracking.frame = CGRectMake(crop.origin.x * size.width,
                                crop.origin.y * size.height,
                                crop.size.width * size.width,
                                crop.size.height * size.height);
    tracking.opacity = 0;
    [CATransaction commit];
}

- (void) updateCrop
{
}

static inline CGFloat rotationForInterfaceOrientation (int orient)
{
    // resolve camera/device image orientation to view/interface orientation
    switch(orient)
    {
    case UIInterfaceOrientationLandscapeLeft:
        return(M_PI_2);         // 90度
    case UIInterfaceOrientationPortraitUpsideDown:
        return(M_PI);           // 180度
    case UIInterfaceOrientationLandscapeRight:
        return(3 * M_PI_2);     // 270度
    case UIInterfaceOrientationPortrait:
        return(2 * M_PI);       // 360度
    }
    return(0);
}

- (void) layoutSubviews
{
    CGRect bounds = self.bounds;
    if(!bounds.size.width || !bounds.size.height)
        return;

    // 如果需要变更，则设置动画的变换效果
    [CATransaction begin];
    if(animationDuration) {
        [CATransaction setAnimationDuration: animationDuration];
        [CATransaction setAnimationTimingFunction:
            [CAMediaTimingFunction functionWithName:
                kCAMediaTimingFunctionEaseInEaseOut]];
    }
    else
        [CATransaction setDisableActions: YES];

    [super layoutSubviews];
    
    // 布局fps的位置
    fpsView.frame = CGRectMake(bounds.size.width - 80, bounds.size.height - 32,
                               80 + 12, 32 + 12);

    // 调整视图的坐标系适配相机的坐标系（相机的坐标系默认是横屏）
    // 如果是竖屏，就把宽高互换
    // orient view bounds to match camera image
    CGSize psize;
    if(UIInterfaceOrientationIsPortrait(interfaceOrientation))
        psize = CGSizeMake(bounds.size.height, bounds.size.width);
    else
        psize = bounds.size;

    // 计算图片的缩放比例（涉及到展示区域的大小与摄像头采样的大小）
    // calculate scale from view coordinates to image coordinates
    // FIXME assumes AVLayerVideoGravityResizeAspectFill
    CGFloat scalex = imageSize.width / psize.width;
    CGFloat scaley = imageSize.height / psize.height;
    imageScale = (scalex < scaley) ? scalex : scaley;
    if(!imageScale)
        imageScale = 1;
    // apply zoom
    imageScale /= zoom;

    // scale crop by zoom factor
    CGFloat z = 1 / zoom;
    CGFloat t = (1 - z) / 2;
    CGRect zoomCrop =
        CGRectMake(scanCrop.origin.x * z + t,
                   scanCrop.origin.y * z + t,
                   scanCrop.size.width * z,
                   scanCrop.size.height * z);

    // 根据视图大小计算采样到的图片
    // convert effective preview area to normalized image coordinates
    CGRect previewCrop;
    if(scalex < scaley && imageSize.height)
        previewCrop.size =
            CGSizeMake(z, psize.height * imageScale / imageSize.height);
    else if(imageSize.width)
        previewCrop.size =
            CGSizeMake(psize.width * imageScale / imageSize.width, z);
    else
        previewCrop.size = CGSizeMake(1, 1);
    previewCrop.origin = CGPointMake((1 - previewCrop.size.width) / 2,
                                     (1 - previewCrop.size.height) / 2);

    // clip crop to visible preview area
    effectiveCrop = CGRectIntersection(zoomCrop, previewCrop);
    if(CGRectIsNull(effectiveCrop))
        effectiveCrop = zoomCrop;

    // size preview to match image in view coordinates
    CGFloat viewScale = 1 / imageScale;
    if(imageSize.width && imageSize.height)
        psize = CGSizeMake(imageSize.width * viewScale,
                           imageSize.height * viewScale);

    //
    preview.bounds = CGRectMake(0, 0, psize.height, psize.width);
    // center preview in view
    preview.position = CGPointMake(bounds.size.width / 2,
                                   bounds.size.height / 2);

    // 判断是否需要对预览视图作旋转
    CGFloat angle = rotationForInterfaceOrientation(interfaceOrientation);
    CATransform3D xform =
        CATransform3DMakeAffineTransform(previewTransform);
    preview.transform = CATransform3DRotate(xform, angle, 0, 0, 1);

    // scale overlay to match actual image
    if(imageSize.width && imageSize.height)
    {
        overlay.bounds = CGRectMake(0, 0, imageSize.width, imageSize.height);
    }
    else
    {
        overlay.bounds = CGRectMake(0, 0, psize.width, psize.height);
    }
    // center overlay in preview
    overlay.position = CGPointMake(psize.height / 2, psize.width / 2);

    // image coordinates rotated from preview
    xform = CATransform3DMakeRotation(M_PI_2, 0, 0, 1);
    overlay.transform = CATransform3DScale(xform, viewScale, viewScale, 1);
    
    tracking.borderWidth = imageScale;

#ifndef NDEBUG
    preview.backgroundColor = [UIColor yellowColor].CGColor;
    overlay.borderWidth = 2 * imageScale;
//    cropLayer.borderWidth = 2 * imageScale;
    cropLayer.frame = CGRectMake(effectiveCrop.origin.x * imageSize.width,
                                 effectiveCrop.origin.y * imageSize.height,
                                 effectiveCrop.size.width * imageSize.width,
                                 effectiveCrop.size.height * imageSize.height);
    
    [overlay setHollowRect:cropLayer.frame];
    [overlay setNeedsDisplay];
    
//    [(ZBarCropMaskView*)cropMaskView setHollowRect:cropLayer.frame];
//    
//    [cropMaskView setFrame:self.bounds];
//    cropMaskView.transform = CGAffineTransformMakeRotation(M_PI / 2);
//    [cropMaskView setNeedsDisplay];
    
    zlog(@"layoutSubviews: bounds=%@ orient=%d image=%@ crop=%@ zoom=%g"
         @"=> preview=%@ crop=(z%@ p%@ %@ i%@) scale=%g %c %g = 1/%g overlay=%@",
         NSStringFromCGSize(bounds.size), interfaceOrientation,
         NSStringFromCGSize(imageSize), NSStringFromCGRect(scanCrop), zoom,
         NSStringFromCGSize(psize), NSStringFromCGRect(zoomCrop),
         NSStringFromCGRect(previewCrop), NSStringFromCGRect(effectiveCrop),
         NSStringFromCGRect(cropLayer.frame),
         scalex, (scalex > scaley) ? '>' : '<', scaley, viewScale, NSStringFromCGRect(overlay.frame));
#endif

    [self resetTracking];
    [self updateCrop];

    [CATransaction commit];
    animationDuration = 0;
}

- (void) setImageSize: (CGSize) size
{
    zlog(@"imageSize=%@", NSStringFromCGSize(size));
    imageSize = size;

    // FIXME bug in AVCaptureVideoPreviewLayer fails to update preview location
    preview.bounds = CGRectMake(0, 0, size.width, size.height);

    [self setNeedsLayout];
}

- (void) willRotateToInterfaceOrientation: (UIInterfaceOrientation) orient
                                 duration: (NSTimeInterval) duration
{
    if(interfaceOrientation != orient) {
        zlog(@"orient=%d #%g", orient, duration);
        interfaceOrientation = orient;
        animationDuration = duration;
    }
}

- (void) setScanCrop: (CGRect) r
{
    if(CGRectEqualToRect(scanCrop, r))
        return;
    scanCrop = r;
    [self setNeedsLayout];
}

- (void) setTracksSymbols: (BOOL) track
{
    if(track == tracksSymbols)
        return;
    tracksSymbols = track;
    [self resetTracking];
}

- (BOOL) allowsPinchZoom
{
    return(pinch.enabled);
}

- (void) setAllowsPinchZoom: (BOOL) enabled
{
    pinch.enabled = enabled;
}

- (void) setTrackingColor: (UIColor*) color
{
    if(!color)
        return;
    [color retain];
    [trackingColor release];
    trackingColor = color;
    tracking.borderColor = color.CGColor;
}

- (void) setShowsFPS: (BOOL) show
{
    if(show == showsFPS)
        return;
    fpsView.hidden = !show;
}

- (void) setZoom: (CGFloat) z
{
    if(z < 1.0)
        z = 1.0;
    if(z > maxZoom)
        z = maxZoom;
    if(z == zoom)
        return;
    zoom = z;

    [self setNeedsLayout];
}

- (void) setZoom: (CGFloat) z
        animated: (BOOL) animated
{
    [CATransaction begin];
    if(animated) {
        [CATransaction setAnimationDuration: .1];
        [CATransaction setAnimationTimingFunction:
            [CAMediaTimingFunction functionWithName:
                kCAMediaTimingFunctionLinear]];
    }
    else
        [CATransaction setDisableActions: YES];
    // FIXME animate from current value
    self.zoom = z;
    [self layoutIfNeeded];
    [CATransaction commit];
}

- (void) setPreviewTransform: (CGAffineTransform) xfrm
{
    previewTransform = xfrm;
    [self setNeedsLayout];
}

- (void) start
{
    if(started)
        return;
    started = YES;

    [self resetTracking];
    fpsLabel.text = @"--- fps ";

    [[UIDevice currentDevice]
        beginGeneratingDeviceOrientationNotifications];
}

- (void) stop
{
    if(!started)
        return;
    started = NO;

    [[UIDevice currentDevice]
        endGeneratingDeviceOrientationNotifications];
}

- (void) flushCache
{
}

// UIGestureRecognizer callback

- (void) handlePinch
{
    if(pinch.state == UIGestureRecognizerStateBegan)
        zoom0 = zoom;
    CGFloat z = zoom0 * pinch.scale;
    [self setZoom: z
          animated: YES];

    if((zoom < 1.5) != (z < 1.5)) {
        int d = (z < 1.5) ? 3 : 2;
        ZBarImageScanner *scanner = self.scanner;
        @synchronized(scanner) {
            [scanner setSymbology: 0
                     config: ZBAR_CFG_X_DENSITY
                     to: d];
            [scanner setSymbology: 0
                     config: ZBAR_CFG_Y_DENSITY
                     to: d];
        }
    }
}

- (void) updateTracking: (CALayer*) trk
             withSymbol: (ZBarSymbol*) sym
{
    if(!sym)
        return;

    CGRect r = sym.bounds;
    if(r.size.width <= 32 && r.size.height <= 32)
        return;
    r = CGRectInset(r, -24, -24);

    CALayer *current = trk.presentationLayer;
    CGPoint cp = current.position;
    CGPoint p = CGPointMake(CGRectGetMidX(r), CGRectGetMidY(r));
    p = CGPointMake((p.x * 3 + cp.x) / 4, (p.y * 3 + cp.y) / 4);

    CGRect cr = current.bounds;
    r.origin = cr.origin;
    r.size.width = (r.size.width * 3 + cr.size.width) / 4;
    r.size.height = (r.size.height * 3 + cr.size.height) / 4;

    CAMediaTimingFunction *linear =
        [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionLinear];

    CABasicAnimation *resize =
        [CABasicAnimation animationWithKeyPath: @"bounds"];
    resize.fromValue = [NSValue valueWithCGRect: cr];
    resize.toValue = [NSValue valueWithCGRect: r];
    resize.duration = .2;
    resize.timingFunction = linear;
    resize.fillMode = kCAFillModeForwards;
    resize.removedOnCompletion = NO;

    CABasicAnimation *move =
        [CABasicAnimation animationWithKeyPath: @"position"];
    move.fromValue = [NSValue valueWithCGPoint: cp];
    move.toValue = [NSValue valueWithCGPoint: p];
    move.duration = .2;
    move.timingFunction = linear;
    move.fillMode = kCAFillModeForwards;
    move.removedOnCompletion = NO;

    CABasicAnimation *on =
        [CABasicAnimation animationWithKeyPath: @"opacity"];
    on.fromValue = [NSNumber numberWithDouble: current.opacity];
    on.toValue = [NSNumber numberWithDouble: 1];
    on.duration = .2;
    on.timingFunction = linear;
    on.fillMode = kCAFillModeForwards;
    on.removedOnCompletion = NO;

    CABasicAnimation *off = nil;
    if(!TARGET_IPHONE_SIMULATOR) {
        off = [CABasicAnimation animationWithKeyPath: @"opacity"];
        off.fromValue = [NSNumber numberWithDouble: 1];
        off.toValue = [NSNumber numberWithDouble: 0];
        off.beginTime = .5;
        off.duration = .5;
        off.timingFunction = linear;
    }

    CAAnimationGroup *group = [CAAnimationGroup animation];
    group.animations = [NSArray arrayWithObjects: resize, move, on, off, nil];
    group.duration = 1;
    group.fillMode = kCAFillModeForwards;
    group.removedOnCompletion = !TARGET_IPHONE_SIMULATOR;
    [trk addAnimation: group
         forKey: @"tracking"];
}

- (void) didTrackSymbols: (ZBarSymbolSet*) syms
{
    if(!tracksSymbols)
        return;

    int n = syms.count;
    assert(n);
    if(!n)
        return;

    ZBarSymbol *sym = nil;
    for(ZBarSymbol *s in syms)
        if(!sym || s.type == ZBAR_QRCODE || s.quality > sym.quality)
            sym = s;
    assert(sym);
    if(!sym)
        return;

    [self updateTracking: tracking
          withSymbol: sym];
}

@end
